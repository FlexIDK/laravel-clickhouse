<?php

declare(strict_types=1);

namespace One23\LaravelClickhouse\Database\Query;

use BackedEnum;
use Closure;
use Illuminate\Contracts\Database\Query\Builder as BuilderContract;
use Illuminate\Database\Eloquent\Relations\Relation;
use Illuminate\Support\Arr;
use Illuminate\Support\Collection;
use Illuminate\Support\Traits\ForwardsCalls;
use Illuminate\Support\Traits\Macroable;
use InvalidArgumentException;
use One23\LaravelClickhouse\Database\Connection;
use One23\LaravelClickhouse\Database\Eloquent\Builder as EloquentBuilder;
use Tinderbox\ClickhouseBuilder\Integrations\Laravel\Builder as BaseBuilder;
use Tinderbox\ClickhouseBuilder\Query\Enums\Operator;
use Tinderbox\ClickhouseBuilder\Query\Expression;
use UnitEnum;

class Builder extends BaseBuilder implements BuilderContract
{
    use ForwardsCalls;
    use Macroable {
        __call as macroCall;
    }

    public $processor;

    public $bindings = [
        'select' => [],
        'from' => [],
        'join' => [],
        'where' => [],
        'groupBy' => [],
        'having' => [],
        'order' => [],
        'union' => [],
        'unionOrder' => [],
    ];

    public $aggregate;

    public $distinct = false;

    /** @var array */
    public $unionOrders;

    public $useWritePdo = false;

    public function __construct(
        Connection $connection,
        ?Grammar $grammar = null
    ) {
        $this->connection = $connection;
        $this->grammar = $grammar ?: new Grammar();
    }

    //
    // select
    // selectSub
    //

    /**
     * @param  string  $expression
     */
    public function selectRaw($expression, array $bindings = [])
    {
        $this->addSelect(new Expression($expression));

        if ($bindings) {
            $this->addBinding($bindings, 'select');
        }

        return $this;
    }

    //
    // fromSub
    // fromRaw
    // createSub
    // parseSub
    // prependDatabaseNameIfCrossDatabaseQuery
    // addSelect
    // distinct
    // from
    // useIndex
    // forceIndex
    // ignoreIndex
    // join
    // joinWhere
    // joinSub
    // joinLateral
    // leftJoinLateral
    // leftJoin
    // leftJoinWhere
    // leftJoinSub
    // rightJoin
    // rightJoinWhere
    // rightJoinSub
    // crossJoin
    // crossJoinSub
    // newJoinClause
    // newJoinLateralClause
    // mergeWheres
    //

    public function where($column, $operator = null, $value = null, string $concatOperator = Operator::AND)
    {
        if (is_array($column)) {
            return $this->addArrayOfWheres($column, $concatOperator);
        }

        return parent::where($column, $operator, $value, $concatOperator); // TODO: Change the autogenerated stub
    }

    protected function addArrayOfWheres($column, $boolean, $method = 'where')
    {
        foreach ($column as $key => $value) {
            if (is_numeric($key) && is_array($value)) {
                $this->{$method}(...array_values($value));
            } else {
                $this->{$method}($key, '=', $value, $boolean);
            }
        }

        return $this;
    }

    public function prepareValueAndOperator($value, $operator, $useDefault = false): array
    {
        // todo
        return parent::prepareValueAndOperator($value, $operator, $useDefault);
    }

    // invalidOperatorAndValue
    // invalidOperator
    // isBitwiseOperator
    // orWhere
    // whereNot
    // orWhereNot
    // whereColumn
    // orWhereColumn
    // whereRaw
    // orWhereRaw
    // whereIn
    // orWhereIn
    // whereNotIn
    // orWhereNotIn
    // whereIntegerInRaw
    // orWhereIntegerInRaw
    // whereIntegerNotInRaw
    // orWhereIntegerNotInRaw

    public function whereNull($columns, $boolean = 'AND', $not = false)
    {
        $type = $not ? 'IS NOT NULL' : 'IS NULL';

        foreach (Arr::wrap($columns) as $column) {
            $this->whereRaw("`{$column}` {$type}");
        }

        return $this;
    }

    public function orWhereNull($column)
    {
        return $this->whereNull($column, 'OR');
    }

    public function whereNotNull($columns, $boolean = 'AND')
    {
        return $this->whereNull($columns, $boolean, true);
    }

    // whereBetween
    // whereBetweenColumns
    // orWhereBetween
    // orWhereBetweenColumns
    // whereNotBetween
    // whereNotBetweenColumns
    // orWhereNotBetween
    // orWhereNotBetweenColumns
    // orWhereNotNull
    // whereDate
    // orWhereDate
    // whereTime
    // orWhereTime
    // whereDay
    // orWhereDay
    // whereMonth
    // orWhereMonth
    // whereYear
    // orWhereYear
    // addDateBasedWhere
    // whereNested
    // forNestedWhere
    // addNestedWhereQuery
    // whereSub
    // whereExists
    // orWhereExists
    // whereNotExists
    // orWhereNotExists
    // addWhereExistsQuery
    // whereRowValues
    // orWhereRowValues
    // whereJsonContains
    // orWhereJsonContains
    // whereJsonDoesntContain
    // orWhereJsonDoesntContain
    // whereJsonOverlaps
    // orWhereJsonOverlaps
    // whereJsonDoesntOverlap
    // orWhereJsonDoesntOverlap
    // whereJsonContainsKey
    // orWhereJsonContainsKey
    // whereJsonDoesntContainKey
    // orWhereJsonDoesntContainKey
    // whereJsonLength
    // orWhereJsonLength
    // dynamicWhere
    // addDynamic
    // whereFullText
    // orWhereFullText
    // whereAll
    // orWhereAll
    // whereAny
    // orWhereAny
    // groupBy

    public function groupByRaw($sql, array $bindings = [])
    {
        $this->addGroupBy(new Expression($sql));

        $this->addBinding($bindings, 'groupBy');

        return $this;
    }

    // having
    // orHaving
    // havingNested
    // addNestedHavingQuery
    // havingNull
    // orHavingNull
    // havingNotNull
    // orHavingNotNull
    // havingBetween
    // havingRaw
    // orHavingRaw
    // orderBy
    // orderByDesc
    // latest
    // oldest
    // inRandomOrder
    // orderByRaw
    // skip
    // offset
    // take
    // limit
    // groupLimit

    public function forPage($page, $perPage = 15)
    {
        return $this->limit(
            $perPage,
            ($page - 1) * $perPage
        );
    }

    public function forPageBeforeId($perPage = 15, $lastId = 0, $column = 'id')
    {
        $this->orders = $this->removeExistingOrdersFor($column);

        if (! is_null($lastId)) {
            $this->where($column, '<', $lastId);
        }

        return $this->orderBy($column, 'desc')
            ->limit($perPage);
    }

    public function forPageAfterId($perPage = 15, $lastId = 0, $column = 'id')
    {
        $this->orders = $this->removeExistingOrdersFor($column);

        if (! is_null($lastId)) {
            $this->where($column, '>', $lastId);
        }

        return $this->orderBy($column, 'asc')
            ->limit($perPage);
    }

    public function reorder($column = null, $direction = 'asc')
    {
        $this->orders = null;
        $this->unionOrders = null;
        $this->bindings['order'] = [];
        $this->bindings['unionOrder'] = [];

        if ($column) {
            return $this->orderBy($column, $direction);
        }

        return $this;
    }

    protected function removeExistingOrdersFor($column)
    {
        return Collection::make($this->orders)
            ->reject(function($order) use ($column) {
                return isset($order['column'])
                    ? $order['column'] === $column : false;
            })->values()->all();
    }

    // union
    // unionAll
    // lock
    // lockForUpdate
    // sharedLock
    // beforeQuery
    // applyBeforeQueryCallbacks
    // afterQuery
    // applyAfterQueryCallbacks
    // toSql
    // toRawSql
    // find
    // findOr
    // value
    // rawValue
    // soleValue

    public function get($columns = ['*']): Collection
    {
        return collect($this->onceWithColumns(Arr::wrap($columns), function() {
            return parent::get();
        }));
    }

    // runSelect
    // withoutGroupLimitKeys
    // paginate
    // simplePaginate
    // cursorPaginate
    // ensureOrderForCursorPagination

    public function getCountForPagination($columns = ['*'])
    {
        $results = $this->runPaginationCountQuery($columns);

        // Once we have run the pagination count query, we will get the resulting count and
        // take into account what type of query it was. When there is a group by we will
        // just return the count of the entire results set since that will be correct.
        if (! isset($results[0])) {
            return 0;
        } elseif (is_object($results[0])) {
            return (int)$results[0]->aggregate;
        }

        return (int)array_change_key_case((array)$results[0])['aggregate'];
    }

    protected function runPaginationCountQuery($columns = ['*'])
    {
        if ($this->groups || $this->havings) {
            $clone = $this->cloneForPaginationCount();

            if (is_null($clone->columns) && ! empty($this->joins)) {
                $clone->select($this->from . '.*');
            }

            return $this->newQuery()
                ->from(new Expression('(' . $clone->toSql() . ') as `aggregate_table`'))
                ->mergeBindings($clone)
                ->setAggregate('count', $this->withoutSelectAliases($columns))
                ->get()->all();
        }

        $without = $this->unions ? ['orders', 'limit', 'offset'] : ['columns', 'orders', 'limit', 'offset'];

        return $this->cloneWithout($without)
            ->cloneWithoutBindings($this->unions ? ['order'] : ['select', 'order'])
            ->setAggregate('count', $this->withoutSelectAliases($columns))
            ->get()->all();
    }

    protected function cloneForPaginationCount(): Builder
    {
        return $this->cloneWithout(['orders', 'limit', 'offset'])
            ->cloneWithoutBindings(['order']);
    }

    protected function withoutSelectAliases(array $columns)
    {
        return array_map(function($column) {
            return is_string($column) && ($aliasPosition = stripos($column, ' as ')) !== false
                ? substr($column, 0, $aliasPosition) : $column;
        }, $columns);
    }

    // cursor
    // enforceOrderBy
    // pluck
    // stripTableForPluck
    // pluckFromObjectColumn
    // pluckFromArrayColumn
    // implode
    // exists
    // doesntExist
    // existsOr
    // doesntExistOr

    public function count($column = '*'): int
    {
        $builder = $this->getCountQuery($column);
        $result = $builder->get();

        if (count($this->groups) > 0) {
            return count($result);
        }

        return (int)($result[0]['count'] ?? 0);
    }

    // min
    // max
    // sum
    // avg
    // average
    // aggregate
    // numericAggregate

    protected function setAggregate($function, $columns)
    {
        $this->aggregate = compact('function', 'columns');

        if (empty($this->groups)) {
            $this->orders = null;

            $this->bindings['order'] = [];
        }

        // grammar compileAggregate

        $column = $this->grammar__columnize($this->aggregate['columns']);

        if (is_array($this->distinct)) {
            $column = 'distinct ' . $this->grammar__columnize($this->distinct);
        } elseif ($this->distinct && $column !== '*') {
            $column = 'distinct ' . $column;
        }

        $this->selectRaw(
            $this->aggregate['function'] . '(' . $column . ') as aggregate'
        );

        //

        return $this;
    }

    protected function onceWithColumns($columns, $callback)
    {
        $original = $this->columns;

        if (is_null($original)) {
            $this->columns = $columns;
        }

        $result = $callback();

        $this->columns = $original;

        return $result;
    }

    public function insert(array $values, bool $skipSort = false): bool
    {
        return parent::insert($values, $skipSort);
    }

    // insertOrIgnore
    // insertGetId
    // insertUsing
    // insertOrIgnoreUsing
    // update
    // updateFrom
    // updateOrInsert
    // upsert
    // increment
    // incrementEach
    // decrement
    // decrementEach
    // delete
    // truncate

    public function newQuery(): self
    {
        return new static($this->connection, $this->grammar);
    }

    protected function forSubQuery()
    {
        return $this->newQuery();
    }

    public function getColumns(): array
    {
        // todo
        return ! empty($this->columns)
            ? $this->columns
            : [];
    }

    // raw
    // getUnionBuilders
    // setBindings

    public function getBindings()
    {
        return Arr::flatten($this->bindings);
    }

    public function getRawBindings()
    {
        return $this->bindings;
    }

    public function setBindings(array $bindings, $type = 'where')
    {
        if (! array_key_exists($type, $this->bindings)) {
            throw new InvalidArgumentException("Invalid binding type: {$type}.");
        }

        $this->bindings[$type] = $bindings;

        return $this;
    }

    public function addBinding($value, $type = 'where')
    {
        if (! array_key_exists($type, $this->bindings)) {
            throw new InvalidArgumentException("Invalid binding type: {$type}.");
        }

        if (is_array($value)) {
            $this->bindings[$type] = array_values(array_map(
                [$this, 'castBinding'],
                array_merge($this->bindings[$type], $value),
            ));
        } else {
            $this->bindings[$type][] = $this->castBinding($value);
        }

        return $this;
    }

    public function castBinding($value)
    {
        if ($value instanceof UnitEnum) {
            return $value instanceof BackedEnum ? $value->value : $value->name;
        }

        return $value;
    }

    public function mergeBindings(self $query)
    {
        $this->bindings = array_merge_recursive($this->bindings, $query->bindings);

        return $this;
    }

    public function cleanBindings(array $bindings)
    {
        return collect($bindings)
            ->reject(function($binding) {
                return $binding instanceof Expression;
            })
            ->map([$this, 'castBinding'])
            ->values()
            ->all();
    }

    protected function flattenValue($value)
    {
        return is_array($value) ? head(Arr::flatten($value)) : $value;
    }

    protected function defaultKeyName()
    {
        return 'id';
    }

    public function getConnection(): Connection
    {
        return $this->connection;
    }

    public function getProcessor()
    {
        return $this->processor;
    }

    public function getGrammar()
    {
        return $this->grammar;
    }

    public function useWritePdo()
    {
        $this->useWritePdo = true;

        return $this;
    }

    protected function isQueryable($value)
    {
        return $value instanceof self ||
            $value instanceof EloquentBuilder ||
            $value instanceof Relation ||
            $value instanceof Closure;
    }

    public function clone(): Builder
    {
        return clone $this;
    }

    public function cloneWithout(array $properties)
    {
        return tap($this->clone(), function($clone) use ($properties) {
            foreach ($properties as $property) {
                $clone->{$property} = null;
            }
        });
    }

    public function cloneWithoutBindings(array $except)
    {
        return tap($this->clone(), function($clone) use ($except) {
            foreach ($except as $type) {
                $clone->bindings[$type] = [];
            }
        });
    }

    public function dump(...$args)
    {
        dump(
            $this->toSql(),
            $this->getBindings(),
            ...$args,
        );

        return $this;
    }

    public function dumpRawSql()
    {
        dump($this->toRawSql());

        return $this;
    }

    public function dd()
    {
        dd($this->toSql(), $this->getBindings());
    }

    public function ddRawSql()
    {
        dd($this->toRawSql());
    }

    public function __call($method, $parameters)
    {
        if (static::hasMacro($method)) {
            return $this->macroCall($method, $parameters);
        }

        if (str_starts_with($method, 'where')) {
            return $this->dynamicWhere($method, $parameters);
        }

        static::throwBadMethodCallException($method);
    }

    //
    //
    //

    public function getOrders(): array
    {
        return ! empty($this->orders)
            ? $this->orders
            : [];
    }

    public function getGroups(): array
    {
        return ! empty($this->groups)
            ? $this->groups
            : [];
    }

    public function getHavings(): array
    {
        return ! empty($this->havings)
            ? $this->havings
            : [];
    }

    public function first($columns = ['*'])
    {
        return $this->take(1)->get($columns)->first();
    }

    public function getCountQuery($column = '*')
    {
        return parent::getCountQuery();
    }

    protected function grammar__columnize(array $columns)
    {
        return implode(', ', array_map([$this->grammar, 'wrap'], $columns));
    }
}

<?php

declare(strict_types=1);

namespace One23\LaravelClickhouse\Database\Query;

use BackedEnum;
use Closure;
use Illuminate\Contracts\Database\Query\Builder as BuilderContract;
use Illuminate\Database\Concerns\BuildsQueries;
use Illuminate\Database\Concerns\ExplainsQueries;
use Illuminate\Database\Eloquent\Relations\Relation;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Pagination\Paginator;
use Illuminate\Support\Arr;
use Illuminate\Support\Collection;
use Illuminate\Support\Traits\ForwardsCalls;
use Illuminate\Support\Traits\Macroable;
use InvalidArgumentException;
use One23\LaravelClickhouse\Database\Connection;
use One23\LaravelClickhouse\Database\Eloquent\Builder as EloquentBuilder;
use One23\LaravelClickhouse\Database\Query\Grammars\Grammar;
use One23\LaravelClickhouse\Exceptions\QueryException;
use Tinderbox\ClickhouseBuilder\Integrations\Laravel\Builder as BaseBuilder;
use Tinderbox\ClickhouseBuilder\Query\Enums\Operator;
use Tinderbox\ClickhouseBuilder\Query\Expression;
use Tinderbox\ClickhouseBuilder\Query\Limit;
use UnitEnum;

class Builder extends BaseBuilder implements BuilderContract
{
    use BuildsQueries;
    use ExplainsQueries;
    use ForwardsCalls;
    use Macroable {
        __call as macroCall;
    }

    public $processor;

    public $bindings = [
        'select' => [],
        'from' => [],
        'join' => [],
        'where' => [],
        'groupBy' => [],
        'having' => [],
        'order' => [],
        'union' => [],
        'unionOrder' => [],
    ];

    public $aggregate;

    public $distinct = false;

    /** @var int */
    public $limit;

    /** @var array */
    public $groupLimit;

    /** @var int */
    public $offset;

    /** @var array */
    public $unions;

    /** @var int */
    public $unionLimit;

    /** @var int */
    public $unionOffset;

    /** @var array */
    public $unionOrders;

    public $beforeQueryCallbacks = [];

    protected $afterQueryCallbacks = [];

    public $useWritePdo = false;

    //

    protected ?Limit $baseLimit = null;

    //

    public function __construct(
        Connection $connection,
        ?Grammar $grammar = null
    ) {
        $this->connection = $connection;
        $this->grammar = $grammar ?: new Grammar;
    }

    //
    // select
    // selectSub
    //

    /**
     * @param  string  $expression
     */
    public function selectRaw($expression, array $bindings = [])
    {
        $this->addSelect(new Expression($expression));

        if ($bindings) {
            $this->addBinding($bindings, 'select');
        }

        return $this;
    }

    //
    // fromSub
    // fromRaw
    // createSub

    protected function parseSub($query)
    {
        if ($query instanceof self || $query instanceof EloquentBuilder || $query instanceof Relation) {
            $query = $this->prependDatabaseNameIfCrossDatabaseQuery($query);

            return [$query->toSql(), $query->getBindings()];
        } elseif (is_string($query)) {
            return [$query, []];
        } else {
            throw new InvalidArgumentException(
                'A subquery must be a query builder instance, a Closure, or a string.'
            );
        }
    }

    protected function prependDatabaseNameIfCrossDatabaseQuery($query)
    {
        if ($query->getConnection()->getDatabaseName() !==
            $this->getConnection()->getDatabaseName()) {
            $databaseName = $query->getConnection()->getDatabaseName();

            if (! str_starts_with($query->from, $databaseName) && ! str_contains($query->from, '.')) {
                $query->from($databaseName . '.' . $query->from);
            }
        }

        return $query;
    }

    // addSelect
    // distinct
    // from
    // useIndex
    // forceIndex
    // ignoreIndex
    // join
    // joinWhere
    // joinSub
    // joinLateral
    // leftJoinLateral
    // leftJoin
    // leftJoinWhere
    // leftJoinSub
    // rightJoin
    // rightJoinWhere
    // rightJoinSub
    // crossJoin
    // crossJoinSub
    // newJoinClause
    // newJoinLateralClause
    // mergeWheres
    //

    public function where($column, $operator = null, $value = null, string $concatOperator = Operator::AND)
    {
        if (is_array($column)) {
            return $this->addArrayOfWheres($column, $concatOperator);
        }

        return parent::where($column, $operator, $value, $concatOperator); // TODO: Change the autogenerated stub
    }

    protected function addArrayOfWheres($column, $boolean, $method = 'where')
    {
        foreach ($column as $key => $value) {
            if (is_numeric($key) && is_array($value)) {
                $this->{$method}(...array_values($value));
            } else {
                $this->{$method}($key, '=', $value, $boolean);
            }
        }

        return $this;
    }

    public function prepareValueAndOperator($value, $operator, $useDefault = false): array
    {
        // todo
        return parent::prepareValueAndOperator($value, $operator, $useDefault);
    }

    // invalidOperatorAndValue
    // invalidOperator
    // isBitwiseOperator
    // orWhere
    // whereNot
    // orWhereNot
    // whereColumn
    // orWhereColumn
    // whereRaw
    // orWhereRaw
    // whereIn
    // orWhereIn
    // whereNotIn
    // orWhereNotIn
    // whereIntegerInRaw
    // orWhereIntegerInRaw
    // whereIntegerNotInRaw
    // orWhereIntegerNotInRaw

    public function whereNull($columns, $boolean = 'AND', $not = false)
    {
        $type = $not ? 'IS NOT NULL' : 'IS NULL';

        foreach (Arr::wrap($columns) as $column) {
            $this->whereRaw("`{$column}` {$type}");
        }

        return $this;
    }

    public function orWhereNull($column)
    {
        return $this->whereNull($column, 'OR');
    }

    public function whereNotNull($columns, $boolean = 'AND')
    {
        return $this->whereNull($columns, $boolean, true);
    }

    // whereBetween
    // whereBetweenColumns
    // orWhereBetween
    // orWhereBetweenColumns
    // whereNotBetween
    // whereNotBetweenColumns
    // orWhereNotBetween
    // orWhereNotBetweenColumns
    // orWhereNotNull
    // whereDate
    // orWhereDate
    // whereTime
    // orWhereTime
    // whereDay
    // orWhereDay
    // whereMonth
    // orWhereMonth
    // whereYear
    // orWhereYear
    // addDateBasedWhere
    // whereNested
    // forNestedWhere
    // addNestedWhereQuery
    // whereSub
    // whereExists
    // orWhereExists
    // whereNotExists
    // orWhereNotExists
    // addWhereExistsQuery
    // whereRowValues
    // orWhereRowValues
    // whereJsonContains
    // orWhereJsonContains
    // whereJsonDoesntContain
    // orWhereJsonDoesntContain
    // whereJsonOverlaps
    // orWhereJsonOverlaps
    // whereJsonDoesntOverlap
    // orWhereJsonDoesntOverlap
    // whereJsonContainsKey
    // orWhereJsonContainsKey
    // whereJsonDoesntContainKey
    // orWhereJsonDoesntContainKey
    // whereJsonLength
    // orWhereJsonLength
    // dynamicWhere
    // addDynamic
    // whereFullText
    // orWhereFullText
    // whereAll
    // orWhereAll
    // whereAny
    // orWhereAny
    // groupBy

    public function groupByRaw($sql, array $bindings = [])
    {
        $this->addGroupBy(new Expression($sql));

        $this->addBinding($bindings, 'groupBy');

        return $this;
    }

    // having
    // orHaving
    // havingNested
    // addNestedHavingQuery
    // havingNull
    // orHavingNull
    // havingNotNull
    // orHavingNotNull
    // havingBetween
    // havingRaw
    // orHavingRaw
    // orderBy
    // orderByDesc
    // latest
    // oldest
    // inRandomOrder
    // orderByRaw

    public function skip($value)
    {
        return $this->offset($value);
    }

    public function offset($value)
    {
        $property = $this->unions ? 'unionOffset' : 'offset';

        $this->$property = max(0, (int)$value);

        //

        if ($property === 'offset') {
            if (
                ($this->limit ?? 0) > 0
            ) {
                $this->baseLimit = new Limit(
                    $this->limit,
                    $value
                );
            } else {
                $this->baseLimit = null;
            }
        }

        return $this;
    }

    final public function take(int $limit, ?int $offset = null)
    {
        return $this->limit($limit, $offset);
    }

    public function limit(int $value, ?int $offset = null)
    {
        $property = $this->unions ? 'unionLimit' : 'limit';

        if ($value >= 0) {
            $this->$property = ! is_null($value) ? (int)$value : null;
        }

        if ($property === 'limit') {
            $this->baseLimit = new Limit(
                $value,
                ! is_null($offset)
                    ? $offset
                    : $this->offset
            );
        }

        return $this;
    }

    // groupLimit

    public function forPage($page, $perPage = 15)
    {
        return $this->offset(($page - 1) * $perPage)->limit($perPage);
    }

    public function forPageBeforeId($perPage = 15, $lastId = 0, $column = 'id')
    {
        $this->orders = $this->removeExistingOrdersFor($column);

        if (! is_null($lastId)) {
            $this->where($column, '<', $lastId);
        }

        return $this->orderBy($column, 'desc')
            ->limit($perPage);
    }

    public function forPageAfterId($perPage = 15, $lastId = 0, $column = 'id')
    {
        $this->orders = $this->removeExistingOrdersFor($column);

        if (! is_null($lastId)) {
            $this->where($column, '>', $lastId);
        }

        return $this->orderBy($column, 'asc')
            ->limit($perPage);
    }

    public function reorder($column = null, $direction = 'asc')
    {
        $this->orders = null;
        $this->unionOrders = null;
        $this->bindings['order'] = [];
        $this->bindings['unionOrder'] = [];

        if ($column) {
            return $this->orderBy($column, $direction);
        }

        return $this;
    }

    protected function removeExistingOrdersFor($column)
    {
        return Collection::make($this->orders)
            ->reject(function($order) use ($column) {
                return isset($order['column'])
                    ? $order['column'] === $column : false;
            })->values()->all();
    }

    // union
    // unionAll
    // lock
    // lockForUpdate
    // sharedLock

    public function beforeQuery(callable $callback)
    {
        $this->beforeQueryCallbacks[] = $callback;

        return $this;
    }

    public function applyBeforeQueryCallbacks()
    {
        foreach ($this->beforeQueryCallbacks as $callback) {
            $callback($this);
        }

        $this->beforeQueryCallbacks = [];
    }

    public function afterQuery(Closure $callback)
    {
        $this->afterQueryCallbacks[] = $callback;

        return $this;
    }

    public function applyAfterQueryCallbacks($result)
    {
        foreach ($this->afterQueryCallbacks as $afterQueryCallback) {
            $result = $afterQueryCallback($result) ?: $result;
        }

        return $result;
    }

    public function toSql(): string
    {
        $this->applyBeforeQueryCallbacks();

        return $this->grammar->compileSelect($this);
    }

    public function toRawSql()
    {
        return $this->grammar->substituteBindingsIntoRawSql(
            $this->toSql(), $this->connection->prepareBindings($this->getBindings())
        );
    }

    // find
    // findOr
    // value
    // rawValue
    // soleValue

    public function get($columns = ['*']): Collection
    {
        $items = collect($this->onceWithColumns(Arr::wrap($columns), function() {
            return parent::get();
        }));

        return $this->applyAfterQueryCallbacks(
            isset($this->groupLimit) ? $this->withoutGroupLimitKeys($items) : $items
        );
    }

    // runSelect

    protected function withoutGroupLimitKeys($items)
    {
        $keysToRemove = ['laravel_row'];

        if (is_string($this->groupLimit['column'])) {
            $column = last(explode('.', $this->groupLimit['column']));

            $keysToRemove[] = '@laravel_group := ' . $this->grammar->wrap($column);
            $keysToRemove[] = '@laravel_group := ' . $this->grammar->wrap('pivot_' . $column);
        }

        $items->each(function($item) use ($keysToRemove) {
            foreach ($keysToRemove as $key) {
                unset($item->$key);
            }
        });

        return $items;
    }

    public function paginate($perPage = 15, $columns = ['*'], $pageName = 'page', $page = null, $total = null): LengthAwarePaginator
    {
        $page = $page ?: Paginator::resolveCurrentPage($pageName);

        $total = value($total) ?? $this->getCountForPagination();

        $perPage = $perPage instanceof Closure ? $perPage($total) : $perPage;

        $results = $total ? $this->forPage($page, $perPage)->get($columns) : collect();

        return $this->paginator($results, $total, $perPage, $page, [
            'path' => Paginator::resolveCurrentPath(),
            'pageName' => $pageName,
        ]);
    }

    public function simplePaginate($perPage = 15, $columns = ['*'], $pageName = 'page', $page = null)
    {
        $page = $page ?: Paginator::resolveCurrentPage($pageName);

        $this->offset(($page - 1) * $perPage)->limit($perPage + 1);

        return $this->simplePaginator($this->get($columns), $perPage, $page, [
            'path' => Paginator::resolveCurrentPath(),
            'pageName' => $pageName,
        ]);
    }

    // cursorPaginate
    // ensureOrderForCursorPagination

    public function getCountForPagination($columns = ['*'])
    {
        $results = $this->runPaginationCountQuery($columns);

        // Once we have run the pagination count query, we will get the resulting count and
        // take into account what type of query it was. When there is a group by we will
        // just return the count of the entire results set since that will be correct.
        if (! isset($results[0])) {
            return 0;
        } elseif (is_object($results[0])) {
            return (int)$results[0]->aggregate;
        }

        return (int)array_change_key_case((array)$results[0])['aggregate'];
    }

    protected function runPaginationCountQuery($columns = ['*'])
    {
        if ($this->groups || $this->havings) {
            $clone = $this->cloneForPaginationCount();

            if (is_null($clone->columns) && ! empty($this->joins)) {
                $clone->select($this->from . '.*');
            }

            return $this->newQuery()
                ->from(new Expression('(' . $clone->toSql() . ') as `aggregate_table`'))
                ->mergeBindings($clone)
                ->setAggregate('count', $this->withoutSelectAliases($columns))
                ->get()->all();
        }

        $without = $this->unions ? ['orders', 'limit', 'offset'] : ['columns', 'orders', 'limit', 'offset'];

        return $this->cloneWithout($without)
            ->cloneWithoutBindings($this->unions ? ['order'] : ['select', 'order'])
            ->setAggregate('count', $this->withoutSelectAliases($columns))
            ->get()->all();
    }

    protected function cloneForPaginationCount(): Builder
    {
        return $this->cloneWithout(['orders', 'limit', 'offset'])
            ->cloneWithoutBindings(['order']);
    }

    protected function withoutSelectAliases(array $columns)
    {
        return array_map(function($column) {
            return is_string($column) && ($aliasPosition = stripos($column, ' as ')) !== false
                ? substr($column, 0, $aliasPosition) : $column;
        }, $columns);
    }

    // cursor
    // enforceOrderBy
    // pluck
    // stripTableForPluck
    // pluckFromObjectColumn
    // pluckFromArrayColumn
    // implode
    // exists
    // doesntExist
    // existsOr
    // doesntExistOr

    public function count($column = '*'): int
    {
        $builder = $this->getCountQuery($column);
        $result = $builder->get();

        if (count($this->groups) > 0) {
            return count($result);
        }

        return (int)($result[0]['count'] ?? 0);
    }

    // min
    // max
    // sum
    // avg
    // average
    // aggregate
    // numericAggregate

    protected function setAggregate($function, $columns)
    {
        $this->aggregate = compact('function', 'columns');

        if (empty($this->groups)) {
            $this->orders = null;

            $this->bindings['order'] = [];
        }

        // grammar compileAggregate

        $column = $this->grammar__columnize($this->aggregate['columns']);

        if (is_array($this->distinct)) {
            $column = 'distinct ' . $this->grammar__columnize($this->distinct);
        } elseif ($this->distinct && $column !== '*') {
            $column = 'distinct ' . $column;
        }

        $this->selectRaw(
            $this->aggregate['function'] . '(' . $column . ') as aggregate'
        );

        //

        return $this;
    }

    protected function onceWithColumns($columns, $callback)
    {
        $original = $this->columns;

        if (is_null($original)) {
            $this->columns = $columns;
        }

        $result = $callback();

        $this->columns = $original;

        return $result;
    }

    public function insert(array $values, bool $skipSort = false): bool
    {
        return parent::insert($values, $skipSort);
    }

    // insertOrIgnore
    // insertGetId
    // insertUsing
    // insertOrIgnoreUsing

    /**
     * @return int
     */
    public function update(array $values)
    {
        $this->applyBeforeQueryCallbacks();

        $values = collect($values)->map(function($value) {
            if (! $value instanceof Builder) {
                return ['value' => $value, 'bindings' => $value];
            }

            [$query, $bindings] = $this->parseSub($value);

            return ['value' => new Expression("({$query})"), 'bindings' => fn() => $bindings];
        });

        if ($values->isEmpty()) {
            throw QueryException::cannotUpdateEmptyValues();
        }

        $table = $this->grammar->wrap($this->getFrom()->getTable());

        $cluster = '';
        if (! is_null($this->getOnCluster())) {
            $cluster = " ON CLUSTER {$this->getOnCluster()}";
        }

        $columns = collect($values)->map(function($value, $key) {
            return $this->grammar->wrap($key) . ' = ' . $this->grammar->parameter($value);
        })->implode(', ');

        $where = $this->grammar->compileWheresComponent($this, $this->getWheres());

        $sql = "ALTER TABLE {$table} {$cluster} UPDATE {$columns} {$where};";

        return $this->connection->statement($sql) ? 1 : 0;
    }

    // updateFrom
    // updateOrInsert
    // upsert
    // increment
    // incrementEach
    // decrement
    // decrementEach

    /**
     * @return int
     */
    public function delete($id = null)
    {
        // If an ID is passed to the method, we will set the where clause to check the
        // ID to let developers to simply and quickly remove a single row from this
        // database without manually specifying the "where" clauses on the query.
        if (! is_null($id)) {
            $this->where($this->from . '.id', '=', $id);
        }

        $this->applyBeforeQueryCallbacks();

        $table = $this->grammar->wrap($this->getFrom()->getTable());

        $cluster = '';
        if (! is_null($this->getOnCluster())) {
            $cluster = " ON CLUSTER {$this->getOnCluster()}";
        }

        $where = $this->grammar->compileWheresComponent($this, $this->getWheres());

        $sql = <<<SQL
ALTER TABLE {$table} {$cluster} DELETE {$where};
SQL;

        return $this->connection->statement($sql) ? 1 : 0;
    }

    // truncate

    public function newQuery(): self
    {
        return new static($this->connection, $this->grammar);
    }

    protected function forSubQuery()
    {
        return $this->newQuery();
    }

    public function getColumns(): array
    {
        // todo
        return ! empty($this->columns)
            ? $this->columns
            : [];
    }

    // raw
    // getUnionBuilders
    // setBindings

    public function getBindings()
    {
        return Arr::flatten($this->bindings);
    }

    public function getRawBindings()
    {
        return $this->bindings;
    }

    public function setBindings(array $bindings, $type = 'where')
    {
        if (! array_key_exists($type, $this->bindings)) {
            throw new InvalidArgumentException("Invalid binding type: {$type}.");
        }

        $this->bindings[$type] = $bindings;

        return $this;
    }

    public function addBinding($value, $type = 'where')
    {
        if (! array_key_exists($type, $this->bindings)) {
            throw new InvalidArgumentException("Invalid binding type: {$type}.");
        }

        if (is_array($value)) {
            $this->bindings[$type] = array_values(array_map(
                [$this, 'castBinding'],
                array_merge($this->bindings[$type], $value),
            ));
        } else {
            $this->bindings[$type][] = $this->castBinding($value);
        }

        return $this;
    }

    public function castBinding($value)
    {
        if ($value instanceof UnitEnum) {
            return $value instanceof BackedEnum ? $value->value : $value->name;
        }

        return $value;
    }

    public function mergeBindings(self $query)
    {
        $this->bindings = array_merge_recursive($this->bindings, $query->bindings);

        return $this;
    }

    public function cleanBindings(array $bindings)
    {
        return collect($bindings)
            ->reject(function($binding) {
                return $binding instanceof Expression;
            })
            ->map([$this, 'castBinding'])
            ->values()
            ->all();
    }

    protected function flattenValue($value)
    {
        return is_array($value) ? head(Arr::flatten($value)) : $value;
    }

    protected function defaultKeyName()
    {
        return 'id';
    }

    public function getConnection(): Connection
    {
        return $this->connection;
    }

    public function getProcessor()
    {
        return $this->processor;
    }

    public function getGrammar()
    {
        return $this->grammar;
    }

    public function useWritePdo()
    {
        $this->useWritePdo = true;

        return $this;
    }

    protected function isQueryable($value)
    {
        return $value instanceof self ||
            $value instanceof EloquentBuilder ||
            $value instanceof Relation ||
            $value instanceof Closure;
    }

    public function clone(): Builder
    {
        return clone $this;
    }

    public function cloneWithout(array $properties)
    {
        return tap($this->clone(), function($clone) use ($properties) {
            foreach ($properties as $property) {
                $clone->{$property} = null;
            }
        });
    }

    public function cloneWithoutBindings(array $except)
    {
        return tap($this->clone(), function($clone) use ($except) {
            foreach ($except as $type) {
                $clone->bindings[$type] = [];
            }
        });
    }

    public function dump(...$args)
    {
        dump(
            $this->toSql(),
            $this->getBindings(),
            ...$args,
        );

        return $this;
    }

    public function dumpRawSql()
    {
        dump($this->toRawSql());

        return $this;
    }

    public function dd()
    {
        dd($this->toSql(), $this->getBindings());
    }

    public function ddRawSql()
    {
        dd($this->toRawSql());
    }

    public function __call($method, $parameters)
    {
        if (static::hasMacro($method)) {
            return $this->macroCall($method, $parameters);
        }

        // todo
        //        if (str_starts_with($method, 'where')) {
        //            return $this->dynamicWhere($method, $parameters);
        //        }

        static::throwBadMethodCallException($method);
    }

    //
    //
    //

    public function getOrders(): array
    {
        return ! empty($this->orders)
            ? $this->orders
            : [];
    }

    public function getGroups(): array
    {
        return ! empty($this->groups)
            ? $this->groups
            : [];
    }

    public function getHavings(): array
    {
        return ! empty($this->havings)
            ? $this->havings
            : [];
    }

    public function getUnions(): array
    {
        return ! empty($this->unions)
            ? $this->unions
            : [];
    }

    public function first($columns = ['*'])
    {
        return $this->take(1)->get($columns)->first();
    }

    public function getCountQuery($column = '*')
    {
        return parent::getCountQuery();
    }

    protected function grammar__columnize(array $columns)
    {
        return implode(', ', array_map([$this->grammar, 'wrap'], $columns));
    }

    public function getLimit(): ?Limit
    {
        return $this->baseLimit;
    }

}
